<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog</title>
    <link rel="stylesheet" href="./blog.css">
</head>
<body>
    <header>
        <h1>Welcome! My Blogs Page</h1>
    </header>
    <main>
        <section>
        <h1>Difference Between Local Storage and Session Storage</h1>  
          <div class="">
         <h4>Local Storage:</h4>
          <p>This read-only interface property provides access to the Document,s local storage object, the stored data is stored across browser sessions. Similar to sessionStorage, except that sessionStorage data gets cleared when the page session ends - that is when the page is closed. It is cleared when the last “private” tab of a browser is closed (localStorage data for a document loaded in a private browsing or incognito session).</p>
          <div class="">
         <h4>What is Session Storage?</h4>
          <p>Session Storage objects can be accessed using the sessionStorage read-only property. The difference between sessionStorage and localStorage is that localStorage data does not expire, whereas sessionStorage data is cleared when the page session ends.
            A unique page session gets created once a document is loaded in a browser tab. Page sessions are valid for only one tab at a time. Pages are only saved for the amount of time that the tab or the browser is open; they do not persist after the page reloads and restores. A new session is created each time a tab or window is opened; this is different from session cookies. Each tab/window that is opened with the same URL creates its own sessionStorage.When you duplicate a tab, the sessionStorage from the original tab is copied to the duplicated tab. Closing a window/tab ends the session and clears sessionStorage objects.</p>
          </div>
        </section>
        <section>
        <h1>The Global and Block scope in JS</h1>  
          <div class="">
            <p>In programming, the scope of a variable determines its lifetime. The scope describes if a variable, a function or an object is accessible or inaccessible by different parts of the program during runtime. In this article, we will see examples to cover briefly the global, local and block scopes in JavaScript.</p>
         <h4>The Global scope:</h4>
          <p>A variable exists inside or outside a block. If a variable is declared outside all functions or curly braces ({}), it exists in the global scope. The global variables can be accessed by any line of code in the program, including inside blocks.</p>
          <div class="">
         <h4>The Block scope</h4>
          <p>So far, we've seen variables defined with the var keyword. Var can declare a variable either in the global or local scope. The variables that are declared within the block scope are comparable to local ones. They are available within the block that they are defined.
            The main difference between the local scope and block scope is that the block statements (e.g. if conditions or for loops), don't create a new scope. So the var keyword will not have an effect, because the variables are still in the same scope.</p>
          </div>
        </section>
        <section>
        <h1>How does the Event Loop works in JavaScript?</h1>  
          <div class="">
            <p>Before we discuss the event loop, lets first go through the function of the task queue.
                Back to our timeout example, once the Web API finishes executing the task, it doesn,t just push it back to the Call Stack automatically. It goes to the Task Queue. 
                A queue is a data structure that works on the First in First out principle, so as tasks get pushed into the queue, they get out in that same order. Tasks that have been executed by the Web API,s, which are being pushed to the Task Queue, then go back to the Call Stack to get their result printed out.The event loop is a process that waits for the Call Stack to be clear before pushing callbacks from the Task Queue to the Call Stack. Once the Stack is clear, the event loop triggers and checks the Task Queue for available callbacks. If there are any, it pushes it to the Call Stack, waits for the Call Stack to be clear again, and repeats the same process.</p>
          </div>
        </section>
        <section>
            <h1>How can we get undefined in JavaScript?</h1>  
          <div class="">
            <h4>What is undefined</h4>
            <p>The undefined is a primitive type in JavaScript. So the undefined is a type. And the undefined type has exactly one value that is undefined.</p>
            <h5>1. When you declare a variable and don’t initialize it to a value, the variable will have a value of undefined.</h5>
            <h5>2. If you access a non-existing property of an object, you’ll get undefined.</h5>
            <h5>3. When you call a function with a number of parameters, you often pass the same number of arguments.</h5>
            <h5>4. A function that doesn't have a return statement implicitly returns undefined.</h5>
            <h5>5. When you access an array element that is out-of-bounds, you’ll get the undefined value</h5>
          </div>
        </section>
        
    </main>
</body>
</html>